//
// kbx81's tube clock DMX-512 controller class
// ---------------------------------------------------------------------------
// (c)2019 by kbx81. See LICENSE for details.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>
//
#include <cstdint>
#include "Application.h"
#include "DisplayManager.h"
#include "Dmx-512-Controller.h"
#include "Dmx-512-Packet.h"
#include "Dmx-512-Rx.h"
#include "Hardware.h"
#include "Settings.h"
#include "View.h"


namespace kbxTubeClock {

namespace Dmx512Controller {


// Pitch multiplier - increases the range of available tone pitches/frequencies
//
static const uint8_t cPitchMultiplier = 16;

// Duration of strobe pulses (here, in milliseconds)
//  Time unit depends on frequency of calls to strobeTimer()
static const uint8_t cStrobeDuration = 1;

// Minimum strobe rate when strobe > 0
//
static const uint8_t cStrobeMinimumRate = 20;

// Channel multiplier - used to increase range of intensities and strobe rates
//
static const uint8_t cChannelMultiplier = 4;

// Duration of tones generated by the DMX-512 controller (see cStrobeDuration)
//  Tones are queued by Hardware::tone() so they'll sound constant if needed
static const uint8_t cToneDuration = 60;

// Master intensity level
//
volatile static uint16_t _masterIntensityLevel;

// Counter for strobe delays
//
volatile static uint16_t _strobeCounter;

// Delay between strobe pulses (here, in milliseconds)
//  Time unit depends on frequency of calls to strobeTimer()
volatile static uint16_t _strobeDelay;


void initialize()
{
}


void controller()
{
  Dmx512Packet* currentPacket = Dmx512Rx::getLastPacket();
  // RgbLed dmxLed[2];
  Settings *pSettings = Application::getSettingsPtr();
  uint32_t _top = 0;
  uint16_t pitch, duration, address = pSettings->getRawSetting(Settings::Setting::DmxAddress);
  uint8_t level = 0;
  const Application::OperatingMode opMode[] = { Application::OperatingMode::OperatingModeDmx512Display,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeFixedDisplay,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter,
                                                Application::OperatingMode::OperatingModeTimerCounter };
  const ViewMode viewMode[] = { ViewMode::ViewMode0,
                                ViewMode::ViewMode0,
                                ViewMode::ViewMode2,
                                ViewMode::ViewMode3,
                                ViewMode::ViewMode0,
                                ViewMode::ViewMode1,
                                ViewMode::ViewMode2,
                                ViewMode::ViewMode3 };

  if (currentPacket->startCode() == 0)
  {
    if (pSettings->getSetting(Settings::Setting::SystemOptions, Settings::SystemOptionsBits::DmxExtended) == true)
    {
      level = currentPacket->channel(address++) / 32;
      Application::setOperatingMode(opMode[level]);
      Application::setViewMode(viewMode[level]);
      // volume only uses upper three bits
      level = currentPacket->channel(address++) >> 5;
      Hardware::setVolume(level);

      pitch = currentPacket->channel(address++);
      Hardware::tone(pitch * cPitchMultiplier, cToneDuration);

      _strobeDelay = currentPacket->channel(address++) * cChannelMultiplier;
      if (_strobeDelay > 0)
      {
        _strobeDelay += cStrobeMinimumRate;
      }
      else
      {
        _strobeCounter = 0;
      }

      duration = currentPacket->channel(address++) * cChannelMultiplier;

      // Set display blanking/driver current level
      _top = (currentPacket->channel(address++) * NixieGlyph::cGlyph100Percent);

      // dmxLed[0].setDuration(duration);
      // dmxLed[0].setRed(currentPacket->channel(address++) << cChannelMultiplier);
      // dmxLed[0].setGreen(currentPacket->channel(address++) << cChannelMultiplier);
      // dmxLed[0].setBlue(currentPacket->channel(address++) << cChannelMultiplier);
      //
      // dmxLed[1].setDuration(duration);
      // dmxLed[1].setRed(currentPacket->channel(address++) << cChannelMultiplier);
      // dmxLed[1].setGreen(currentPacket->channel(address++) << cChannelMultiplier);
      // dmxLed[1].setBlue(currentPacket->channel(address++) << cChannelMultiplier);

      // pSettings->setColors(Settings::Slot::SlotDmx, dmxLed[0], dmxLed[1]);
    }
    else
    {
      _top = (currentPacket->channel(address) * NixieGlyph::cGlyph100Percent);
    }
    _masterIntensityLevel = static_cast<uint16_t>(_top / 255);
    DisplayManager::setMasterIntensity(_masterIntensityLevel);
  }
}


void strobeTimer()
{
  if (Application::getExternalControlState() == Application::ExternalControl::Dmx512ExtControlEnum)
  {
    if (_strobeDelay > 0)
    {
      _strobeCounter++;
    }

    if (((_masterIntensityLevel > 0) && (_strobeDelay == 0)) ||
        ((_masterIntensityLevel > 0) && (_strobeDelay > 0) && (_strobeCounter > _strobeDelay)))
    {
      DisplayManager::setDisplayBlanking(false);
      if (_strobeCounter > _strobeDelay + cStrobeDuration)
      {
        _strobeCounter = 0;
      }
    }
    else
    {
      DisplayManager::setDisplayBlanking(true);
    }
  }
}


}

}
